<!DOCTYPE html>
<html lang="en">
<head>
  <title>player.html</title>
  <meta charset="utf-8">
  <meta name="description" content="Drop player.html in a folder of videos and play them on the web" />
  <meta name="version" content="1.0.0">
  <meta name="Copyright" content=" ©2020 Paul Ellis">
  <meta name="license" content="https://opensource.org/licenses/MIT">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="shortcut icon"
    href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQBAMAAAAVaP+LAAAAMFBMVEX////+8vn+4fP+zuz+tuL+n9r+l9f+gc7+bMb+XcD+Rbj+MK/+Hqj+D6P+BZ/+AJ2hzeniAAABZ0lEQVR42u3UO3HDQABF0QdhISgMdiYEBEEAMokgWBBEQRAiCBYE2xAsCJLzmdTWZ1/KtClu5dkL4JRXuVwul8vl/tmzoF5bMb3tNQR5LSHISwFBngME+UJBHijop4MgpwaCvFUQ5DVCkO8FBHkMEJTOEOTUQ5BTB0H+PkBQ+ioZyF4iBHkOEOQrBXmgIL9TkBsK2msISmsEoL+nEJCnAEE+U1A6QpDdUdDeQJC3EoK8RAjyLUCQRwpKJwiyewpKLQR5ryHIawlB/iggKE2BgewLBfkIQamFoF4MNIiBrmKgOTDQEoVAWykE2hsxUCcG6sVAZzHQFBjoXgiB1igE2iohUGrEQJ0YaBADXcVAc2CgJQqBtlIItB+EQKkVA/VioJMYaAwMdC+EQJ9RCLRVQqDUiIE6MdBRDHQRA02BgZZCCLSWQqC9FgKlVgzUi4FOYqBRDHQrGGiJQnqpxPSkXC6Xy+VyD9ovn971FIU9/uIAAAAASUVORK5CYII=" />
  <style>
    *,
    *::before,
    *::after {
      -moz-box-sizing: border-box;
      -webkit-box-sizing: border-box;
      box-sizing: border-box;

      user-select: none;

      line-height: 1rem;

      --tile-aspect-ratio: calc(9/16);
      --tile-width: 22rem;
      --tile-height: calc(var(--tile-width) * var(--tile-aspect-ratio));
      --tile-border-radius: 0.25rem;
      --inter-tile-margin: 0.5rem;

      --theme-color: #FD009C;
      --folder-color: #FED45A;
      --playing-color: #8cff00;
    }

    html {
      font-family: 'Segoe UI', Calibri, Arial, Helvetica, sans-serif;
      font-size: 12px;
      background-color: #111;
      color: #FFF;
    }

    body {
      padding: 0;
      margin: 0 auto;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      flex-wrap: wrap;
    }

    video {
      width: 100vw;
      min-height: 30vw;
      max-height: min(
        calc(100vh - var(--tile-height)),
        /* Full height minus some space to see the first row of tiles */
        calc(100vw * var(--tile-aspect-ratio))
        /* Height for the current width at the specified aspect ratio */
      );
      margin: auto;
      background: #000;
    }

    .buttons {
      width: 100%;
      text-align: center;
      margin-top: 1rem;
    }

    .buttons button {
      background: none;
      border: 0 none;
      cursor: pointer;
      padding: 0;
      font-size: 2rem;
      margin: 1rem 0;
    }

    .buttons svg {
      fill: var(--theme-color);
    }

    .buttons svg:hover {
      filter: saturate(0.25) brightness(4);
    }

    .buttons .stop svg {
      margin: 0 0.5rem;
    }

    .links {
      max-width: 100vw;
      margin-top: 1rem;
      display: grid;
      grid-gap: var(--inter-tile-margin);
      grid-template-columns: repeat(auto-fill, var(--tile-width));

      padding-bottom: 2rem;
    }

    .links a {
      /* background */
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;

      width: var(--tile-width);
      height: var(--tile-height);

      padding: 0;
      border-radius: var(--tile-border-radius);

      background-color: #666;
      color: #DDD;
      text-decoration: none;
    }

    .links a .title {
      /* Title */
      position: absolute;
      display: block;
      bottom: 0;
      left: 0;

      width: 100%;

      overflow-wrap: break-word;
      font-size: 1.25rem;
      line-height: 1.5rem;
      text-align: left;
      padding: 1rem;

      background: rgba(32, 32, 32, 0.75);
      border-radius: 0 0 var(--tile-border-radius) var(--tile-border-radius);
    }

    .folder .title svg, .folder .title svg g {
      height: 1em;
      width: 1em;
      margin-bottom: -0.18em;
    }
    .folder:first-of-type .title svg {
      display: inline-block;
    }

    .links a.folder .arrow,
    .links a.file .arrow {
      /* Arrow */
      font-size: 3rem;
      display: block;
      text-align: center;
      padding: 0;
    }

    .links a.file .arrow {
      filter: drop-shadow(0 0 0.1rem rgba(0, 0, 0, 0.5));
    }

    .links a.file {
      background-size: cover;
      background-image: var(--image-url);
    }

    .links a.file:hover:not(.current) {
      background-blend-mode: luminosity;
    }

    .current {
      background-blend-mode: soft-light;
    }

    .links a.folder {
      background-color: #333;
    }

    /* SVG Icons */
    .xlinks {
      display: none;
    }
    
    .buttons svg, .buttons svg g, .arrow svg, .arrow svg g {
      width: 30px;
      height: 30px;
      transform: scale(1.25);
    }

    .file:hover .arrow svg,
    .folder:hover .arrow svg,
    .file.current .arrow svg {
      transform: scale(2) rotate(360deg);
    }

    .file svg,
    .file svg path,
    .folder svg,
    .folder svg path {
      fill: #FFF;
      transition: all 500ms ease;
    }

    .file:hover svg {
      fill: var(--theme-color);
    }

    .current .arrow svg {
      fill: var(--playing-color);
    }

    .folder svg {
      fill: var(--folder-color);
      transition: all 250ms;
    }

    .folder:hover svg {
      filter: brightness(2);
    }

    .folder .arrow .closed, .folder:first-of-type .arrow .open {
      display: block;
    }
    .folder .arrow .open, .folder:first-of-type .arrow .closed {
      display: none;
    }

    
  </style>
</head>

<body>
  <video controls></video>

  <section class="buttons">
    <button class="replay play" type="button" title="Replay"><svg><g><use xlink:href="#svgReplay"></g>
    </svg></button><button class="stop" type="button" title="Stop"><svg><g><use xlink:href="#svgStop"></g>
    </svg></button><button class="skip" type="button" title="Skip"><svg><g><use xlink:href="#svgSkip"></g>
    </svg></button>
  </section>
  <section class="links"></section>
  <section class="xlinks">
    <!-- https://github.com/microsoft/fluentui-system-icons -->
    <!-- ic_fluent_play_24_filled.svg -->
    <svg id="svgFile"><path d="M6.33994976,2.27500912 C5.25284495,1.67304649 3.88358525,2.06633193 3.28162262,3.15343674 C3.09690734,3.48702035 3,3.86207592 3,4.2433865 L3,19.7591388 C3,21.0017795 4.00735931,22.0091388 5.25,22.0091388 C5.63140051,22.0091388 6.00654154,21.9121858 6.34018202,21.7273876 L20.3484443,13.9684314 C21.4354781,13.3663405 21.8286019,11.9970344 21.226511,10.9100006 C21.0219396,10.540661 20.7175758,10.2363331 20.348212,10.0318053 L6.33994976,2.27500912 Z"/></svg>
    <!-- ic_fluent_folder_24_filled.svg -->
    <svg id="svgFolderClosed"><path d="M13.821,6.5 L19.75,6.5 C20.8867338,6.5 21.826582,7.34296748 21.9785265,8.43788437 L21.9948092,8.59595119 L22,8.75 L22,17.75 C22,18.940864 21.0748384,19.9156449 19.9040488,19.9948092 L19.75,20 L4.25,20 C3.05913601,20 2.08435508,19.0748384 2.00519081,17.9040488 L2,17.75 L2,10.499 L8.2069251,10.5 L8.40335497,10.4914126 C8.79396018,10.4571882 9.16895973,10.3214197 9.49094085,10.0976522 L9.64734,9.97849788 L13.821,6.5 Z M8.2069251,4 C8.66748759,4 9.11529621,4.14128575 9.49094085,4.40234784 L9.64734,4.52150212 L11.75,6.273 L8.6870634,8.82616596 L8.60221452,8.8873763 C8.51362501,8.94231824 8.41452303,8.9781981 8.31129371,8.99270416 L8.2069251,9 L2,8.999 L2,6.25 C2,5.05913601 2.92516159,4.08435508 4.09595119,4.00519081 L4.25,4 L8.2069251,4 Z"/></svg>
    <!-- ic_fluent_folder_open_24_filled.svg -->
    <svg id="svgFolderOpen"><path d="M1.99957 6.24922C2 5.00689 3.00724 4 4.24957 4H8.20509C8.73063 4 9.23959 4.18396 9.64368 4.51998L12.0247 6.49988H17.75C18.9926 6.49988 20 7.50724 20 8.74988V9.50195H6.42105C5.38827 9.50195 4.48811 10.2051 4.23802 11.2071L2.316 18.9079C2.35895 18.7356 2.315 18.9118 2.316 18.9079C2.11246 18.5694 1.99546 18.173 1.99561 17.7492L1.99957 6.24922Z M3.74448 19.3789C3.66573 19.6945 3.90439 20 4.2296 20H18.4693C19.2723 20 19.9722 19.4535 20.167 18.6745L21.9302 11.6232C22.0091 11.3077 21.7704 11.002 21.4451 11.002H6.42105C6.07679 11.002 5.77674 11.2363 5.69337 11.5703L3.74448 19.3789Z"/></svg>
    <!-- ic_fluent_stop_24_filled.svg -->
    <svg id="svgStop"><path d="M4.75 3C3.7835 3 3 3.7835 3 4.75V19.25C3 20.2165 3.7835 21 4.75 21H19.25C20.2165 21 21 20.2165 21 19.25V4.75C21 3.7835 20.2165 3 19.25 3H4.75Z"/></svg>
    <!-- ic_fluent_rewind_24_filled.svg -->
    <svg id="svgReplay"><path d="M21.0015268,4.75008179 L21,18.7500818 C20.9999319,19.374155 20.2821581,19.7251581 19.7895445,19.3420142 L12.5,13.6726109 L12.5,18.7500818 C12.4999319,19.374155 11.7821581,19.7251581 11.2895445,19.3420142 L2.28954454,12.3420142 C1.90346505,12.0417301 1.90348904,11.4582003 2.28959321,11.157948 L11.29112,4.15794799 C11.7838024,3.77481559 12.5015268,4.12596134 12.5015268,4.75008179 L12.5,9.82661094 L19.79112,4.15794799 C20.2838024,3.77481559 21.0015268,4.12596134 21.0015268,4.75008179 Z"/></svg>
    <!-- ic_fluent_fast_forward_24_filled.svg -->
    <svg id="svgSkip"><path d="M12.7104555,4.15798491 L21.7104555,11.1579849 C22.0965349,11.458269 22.096511,12.0417988 21.7104068,12.3420511 L12.70888,19.3420511 C12.2161976,19.7251835 11.4984732,19.3740377 11.4984732,18.7499173 L11.4984732,13.6726109 L4.20887999,19.3420511 C3.71619763,19.7251835 2.9984732,19.3740377 2.9984732,18.7499173 L3,4.74991728 C3.00006806,4.12584403 3.71784185,3.774841 4.21045546,4.15798491 L11.4984732,9.82661094 L11.5,4.74991728 C11.5000681,4.12584403 12.2178419,3.774841 12.7104555,4.15798491 Z"/></svg>
    <!-- ic_fluent_arrow_up_24_filled.svg -->
    <svg id="svgFolderArrow"><path d="M4.28401,10.2955 C3.89639,10.6889 3.90108,11.322 4.29449,11.7097 C4.68789,12.0973 5.32104,12.0926 5.70866,11.6992 L11,6.32889 L11,20 C11,20.5523 11.4477,21 12,21 C12.5523,21 13,20.5523 13,20 L13,6.33538 L18.2849,11.6992 C18.6726,12.0926 19.3057,12.0973 19.6991,11.7097 C20.0925,11.322 20.0972,10.6889 19.7096,10.2955 L12.8872,3.3713 C12.3976,2.87438 11.596,2.87438 11.1064,3.3713 L4.28401,10.2955 Z"/></svg>
  </section>
  <script>
    (async function pwaIIFE() {
      const icon = document.querySelector('link[rel="shortcut icon"').href;
      const metadata = await imageMetadata(icon);

      const manifest = {
        short_name: document.title,
        name: document.title,
        description: document.querySelector('meta[name="description"]').content,
        background_color: '#FFFFFF',
        theme_color: getComputedStyle(document.body).getPropertyValue('--theme-color'),
        color: getComputedStyle(document.body).getPropertyValue('--theme-color'),
        icons: [
          {
            src: icon,
            sizes: `${metadata.width}x${metadata.height}`,
            type: metadata.type
          }
        ],
        display: 'standalone',
        start_url: `${window.location.origin}${window.location.pathname}`

      }

      setPWAManifest(manifest);

      function setPWAManifest(manifest) {
        const json = JSON.stringify(manifest);
        const base64 = btoa(json);
        const mimetype = 'application/json';
        const dataURI = `data:${mimetype};base64,${base64}`;

        const link = document.createElement('link');
        link.setAttribute('rel', 'manifest');
        link.setAttribute('href', dataURI);

        document.querySelector('head').appendChild(link);
      }

      function imageMetadata(dataURI) {
        const img = document.createElement('img');

        const mimeRe = /data:([\w\/]+);/i;
        const type = mimeRe.exec(dataURI)[1];
        
        const promise = new Promise(function (resolve, reject) {
          img.onload = function imageSizeLoad() {
            const width = img.naturalWidth;
            const height = img.naturalHeight;
            resolve({ height, width, type });
          }
        });

        img.src = dataURI;

        return promise;
      }
    })();

    (function socialMetadataIIFE(){
    const metadata = {
      title: document.querySelector('title').textContent,
      description: document.querySelector('meta[name="description"]').content,
      type: 'video.movie',
      icon: document.querySelector('link[rel="shortcut icon"').href,
      backgroundColor: '#FF0099'
    };

    setMetadata(metadata);

    function setMetadata(metadata) {

      function setTitle(title){
        const metas = [
          'og:site_name',
          'twitter:title',
          'og:title'
        ];

        setMetas(metas, title);
      }

      function setIcon(iconDataURI) {
        const metas = [
          'twitter:image:src',
          'msapplicationTileImage',
          'og:image'
        ];

        setMetas(metas, iconDataURI);

        const links = [
          'apple-touch-icon'
        ];

        setLinks(links, iconDataURI);       
      }

      function setMetas(metas, content) {
        metas.forEach(function metaFn(meta) {
          const metadata = {
            prop: meta,
            content: content
          };
          
          append(createMeta(metadata));
        });
      }

      function setLinks(links, href) {
        links.forEach(function linkFn(rel) {
          const link = {
            rel: rel,
            href: href
          };

          append(createLink(link));
        });
      }

      function setDescription(desc) {
        const metas = [
          'og:desctription',
          'twitter:description'
        ];

        setMetas(metas, desc);
      }

      function setType(type){
        const metadata = {
          prop: type,
          content: 'og:type'
        };

        append(createMeta(metadata));
      }
      
      function createLink(linkMetadata) {
        const rel = linkMetadata.rel;
        const href = linkMetadata.href;

        const link = document.createElement('link');
        link.rel = rel;
        link.href = href;
        
        return link;
      }

      function createMeta(metaMetadata) {
        const prop = metaMetadata.prop;
        const content = metaMetadata.content;

        const meta = document.createElement('meta');
        meta.property = prop;
        meta.name = prop;
        meta.content = content;

        return meta;
      }

      function append(el) {
        const $head = document.querySelector('head');
        $head.appendChild(el);
      }


      if (metadata.title) {
        setTitle(metadata.title);
      }

      if (metadata.icon) {
        setIcon(metadata.icon);
      }

      if (metadata.type) {
        setType(metadata.type);
      }

      if (metadata.description) {
        setDescription(metadata.description);
      }

      if (metadata.backgroundColor) {
        append(createMeta({prop: 'msapplication-TileColor', content: metadata.backgroundColor}));
      }
    }

  })();

    (function globalIIFE() {
      'use strict';
      const $video = $('video');

      const options = {
        thumbnails: {
          enabled: true && canThumbnail(),
          timestamp: 0.10,
          size: 480,
          opacity: '0.5',
          color: '32,32,32',
          resizeQuality: 'high',
          concurrency: 1,
          mimeType: getIdealMimeType()
        },
        supportedFileExtensions: getSupportedVideoTypes(),
        poster: getSVGPoster()
      }

      function getSupportedVideoTypes() {
        const supported = [];
        
        const types = [
          { mime: 'video/mp4', extensions: ['mp4', 'm4v'] },
          { mime: 'video/webm', extensions: ['webm', 'mkv'] },
          { mime: 'video/ogg', extensions: ['ogg'] }
        ];

        const v = document.createElement('video');
        types.forEach(type => {
          if (v.canPlayType(type.mime) !== '') supported.push(...type.extensions);
        });

        return supported;
      }

      function getIdealMimeType(){
        const webp = {
          type: 'image/webp',
          quality: 0.2
        }

        const jpeg = {
          type: 'image/jpeg',
          quality: 0.4
        }

        const webpSupport = document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') === 0;

        return (webpSupport ? webp : jpeg);
      }

      function canThumbnail(){
      // Must support `localStorage` and `createImageBitmap`
        try {
            const key = '__canThumbnailTest__';
            const val = 'true';

            localStorage.setItem(key, val);
            const getItemSuccess = localStorage.getItem(key) === val;
            localStorage.removeItem(key);
          return (!!createImageBitmap && !!getItemSuccess);
        } catch (e) {
          return false;
        }
      }

      const hashState = { location: '', video: '' };

      function urlToFolder(url){
        var pieces = url.split('/'); // Break the URL into pieces
        pieces.pop(); // Remove the last piece (the filename)
        return pieces.join('/') + '/'; // Put it back together with a trailing /
      }

      function urlToName(url) {
        return removeFileExtension(
          url.split('/').pop()
        );
      }

      function urlToLabel(url) {
        if (typeof url !== 'string') return;

        const fragments = url.split('/');

        const label = removeFileExtension(
          decodeURIComponent(
            fragments[fragments.length - 1]
          )
        );

        const prefixRe = /^(the|a)(\s|%20)/i;
        const hasPrefix = prefixRe.test(label);

        if (hasPrefix) {
          const prefix = prefixRe.exec(label);
          const length = prefix[1].length + prefix[2].length;
          return `${label.substring(length)}, ${prefix[1]}`;
        } else {
          return label;
        }
      }

      function removeFileExtension(s) {
        const re = new RegExp(`\\.+(${options.supportedFileExtensions.join('|')})+$`, 'i');
        return s.replace(re, '');
      }

      function sortFiles(a, b) {
        const labelA = urlToLabel(a);
        const labelB = urlToLabel(b);
        
        return labelA < labelB ? -1 : 1;
      }

      function urlType(url) {
        function isVideo(haystack, fileExtensions) {
          const re = new RegExp(`\.+(${ options.supportedFileExtensions.join('|')})+$`, 'i');
          return re.test(haystack);
        };


        if (isHiddenFileOrFolder(url)) {
          return 'hidden';
        } else if (url[url.length - 1] === '/') {
          return 'folder';
        } else if (isVideo(url)) {
          return 'file';
        } else {
          return 'unknown';
        }
      }

      function isHiddenFileOrFolder(url) {
        const reHidden = /\/\..+$/i;
        return url.toString().match(reHidden);
      }

      function getLinksFromFrame(frame) {
        const links = [...frame.contentDocument.querySelectorAll('a')];

        const folders = [];
        const files = [];

        links.forEach(function(link){
          const url = link.toString();
          const type = urlType(url);

          switch (type) {
            case 'hidden':
              break;
            case 'file':
              files.push(url);
              break;
            case 'folder':
              folders.push(url);
              break;
          }
        });

        return { folders, files };
      }

      function asyncLinkRequest(url) {
        const $frame = $(document.createElement('iframe'));
        $('body').appendChild($frame);
        
        const promise = new Promise(function asyncLinkRequestPromise(resolve, reject){
          $frame.on('error', reject);
          
          $frame.on('load', function frameLoad() {
            const links = getLinksFromFrame($frame);
            $('body').removeChild($frame);

            resolve(links);
          });

          hideElement($frame);
        });
        
        $frame.src = url; // Setting src starts loading

        return promise;
      }

      async function createLinks(url) {
        const links = await asyncLinkRequest(urlToFolder(url || window.location.href));
        showLinks(links);
      }

      function showLinks(links) {
        var html = '';
        const folders = links.folders;
        const files = links.files;
        const base = getBaseLocation(window.location);

        files.sort(sortFiles);

        folders.forEach(function(folder){
          const rawUrl = folder;
          const url = decodeURI(rawUrl).replace(base, '');
          const label = url;

          html += createFolderTemplate(rawUrl, label);
        });

        files.forEach(function(file){
          const rawUrl = file;
          const url = decodeURI(rawUrl).replace(base, '');
          const label = urlToLabel(url);
          const cssClasses = (rawUrl === $video.src ? 'current' : '');

          html += createFileTemplate(rawUrl, label, cssClasses);
        });

        $('.links').innerHTML = html;

        const $links = [...document.querySelectorAll('.file, .folder')];
        $links.forEach((link) => $(link).on('click', clickLink));

        if (options.thumbnails.enabled) {
          try {
            populateThumbnails();
          } catch (e) { }
        }
      }

      function createFileTemplate(url, label, optionalClasses = '') {
        return `<a href="${url}" class="file ${optionalClasses}" draggable="false" draggable="false"><div class="title" draggable="false">${label}</div><div class="arrow" draggable="false"><svg><g><use xlink:href="#svgFile"></g></svg></div></a>`;
      }

      function createFolderTemplate(url, label, optionalClasses = '') {
        return `<a href="${url}" class="folder ${optionalClasses}" draggable="false"><div class="title" draggable="false"><svg viewBox="0 0 24 24"><g><use xlink:href="#svgFolderArrow"></g></svg>${label}</div></div><div class="arrow" draggable="false"><svg class="open"><g><use xlink:href="#svgFolderOpen"></g></svg><svg class="closed"><g><use xlink:href="#svgFolderClosed"></g></svg></div></a>`;
      }

      function clickLink(e) {
        e.preventDefault();

        // `this` always refers to the parent element. `e.target` can be children too instead.
        const $el = $(this);

        if ($el.hasClass('folder')) {
          hashState.location = $el.href;
          createLinks($el.href);
        }

        if ($el.hasClass('file')) {
          hashState.video = $el.href;
          actionPlay($el.href);
        }

        updateHash();
      }

      function hideElement(el) {
        const s = el.style;
        s.width = 0;
        s.height = 0;
        s.margin = 0;
        s.padding = 0;
        s.border = '0 none';
      }

      async function populateThumbnails(){
        const $files = [...document.querySelectorAll('.file')];
        const promises = [];
        const queue = [];

        $files.forEach(function ($file){
          const url = $file.href;
          promises.push({$file, url});
        });

        const concurrency = options.thumbnails.concurrency;

        for (let j = 0; j < promises.length; j + concurrency) {            
          // If there are promises left shift the first one into the queue            
          if (promises.length > 0) {
            let work = promises.shift();
            queue.push(setThumbnail(work.$file, work.url));
          }

          // If the queue is full/ready run all the promises
          if (queue.length >= concurrency) {
            const results = await Promise.all(queue);
            queue.length = 0; // clears array
          }
        }
      }

      function getState() {
        const location = hashState.location;
        const video = getVideoUrl();
        const state = { location, video }

        return state;
      }

      function getBaseLocation(l) {
        return l.protocol + '//' + l.host;
      }
      
      function getVideoUrl(){
        return $video.src;
      }

      function getHash() {
        const urlHash = window.location.hash.substr(1);

        var hash = {};
        try {
          hash = decodeHash(urlHash);
        } catch (e) { }
        
        return hash;
      }

      function updateHash() {
        location.hash = encodeHash(getState());
      }

      function encodeHash(hash) {
        return encodeURIComponent(btoa(JSON.stringify(hash)));
      }

      function decodeHash(hash) {
        return JSON.parse(atob(decodeURIComponent(hash)));
      }

      function actionPlay(url) {
        // Don't restart playback if it is the currently playing video
        if (url === $video.src) return;

        $video.autoplay = !!url;
        
        if (!!url) {
          $video.poster = '';
          $video.src = url;
          $video.play();
          hashState.video = url;
        } else {
          $video.src = '';
          $video.poster = options.poster;
        }

        setCurrentVideoTile();
      }

      function setCurrentVideoTile() {
        const $former = $('.links .current')        
        if ($former && $former.classList) $former.classList.remove('current');

        const $current = $(`.file[href="${$video.src}"]`);
        if ($current && $current.classList) $current.classList.add('current');
      }

      function actionStop() {
        actionPlay();
      }
      
      function actionReplay() {
        $video.currentTime = Math.max($video.currentTime - 10, 0);
      }
      
      function actionSkip () {
        $video.currentTime = Math.min($video.currentTime + 30, $video.duration);
      }        
      
      function setVideoPoster(r,g,b){
        if (options.poster) {
          return $video.poster = options.poster;
        }

        return $video.poster = createColorDataURI(r,g,b);
      }

      function getSVGPoster() {
        const svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
          <svg width="57" height="35" viewBox="0 0 55 36" version="1.1" xmlns="http://www.w3.org/2000/svg">
            <g transform="translate(4,-6.952508)">
              <path fill="${getThemeColor()}" d="M 13.750134,8.4121203 38.167189,21.116929 c 1.592276,0.828502 2.211438,2.790929 1.382936,4.383205 -0.308051,0.592037 -0.790899,1.074885 -1.382936,1.382937 L 13.750134,39.58788 C 12.157858,40.416381 10.195431,39.797219 9.3669293,38.204943 9.125863,37.741644 9,37.227072 9,36.704809 V 11.295191 c 0,-1.7949254 1.455075,-3.25 3.25,-3.25 0.447654,0 0.889658,0.092471 1.298566,0.2706995 z m -1.153949,2.2177467 -0.110487,-0.04668 c -0.07579,-0.02509 -0.15535,-0.038 -0.235698,-0.038 -0.414214,0 -0.75,0.335786 -0.75,0.75 v 25.409618 c 0,0.120522 0.02904,0.23927 0.08468,0.346185 0.191193,0.367448 0.644061,0.510332 1.011509,0.319139 L 37.01324,24.665324 c 0.136624,-0.07109 0.24805,-0.182515 0.319139,-0.319139 0.191192,-0.367449 0.04831,-0.820316 -0.319139,-1.011509 z"/>
            </g>
          </svg>`;

        const base64 = btoa(svg);
        return `data:image/svg+xml;base64,${base64}`;
      }

      function getThemeColor() {
        return getComputedStyle(document.documentElement).getPropertyValue('--theme-color');
      }

      function getTileAspectRatio() {
        return +getComputedStyle(document.documentElement).getPropertyValue('--tile-aspect-ratio');
      }

      function createColorDataURI(r, g, b, a) {
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;

        const context = canvas.getContext('2d');
        const imageData = context.getImageData(0, 0, 1, 1);
        const subPixels = imageData.data;

        subPixels[0] = r || 0; // r
        subPixels[1] = g || 0; // g
        subPixels[2] = b || 0; // b
        subPixels[3] = a || 255;

        context.putImageData(imageData, 0, 0);

        return canvas.toDataURL('image/png');
      }

      // Thumbnail generation
      function getVideo(url) {
        const $video = document.createElement('video');
        $video.crossorigin = 'anonymous';
        $video.muted = true;
        $video.autoplay = false;
        $video.preload = false;
        $video.playbackRate = 0;
        
        const promise = new Promise(function(resolve, reject){
          $video.addEventListener('loadedmetadata', function loadedmetadata(){
            $video.pause();
            resolve($video);
          }, false);
          
          $video.addEventListener('error', reject);
        });
        $video.src = url;

        return promise;
      }

      function getBitmap(videoSrc, time) {
        const $video = videoSrc;
        
        const promise = new Promise(function(resolve, reject){
          $video.addEventListener('seeked', function seeked(){
            const opts = {
              resizeWidth: options.thumbnails.size,
              resizeQuality: options.thumbnails.resizeQuality
            };

            return createImageBitmap($video, opts).then(resolve).catch(reject);
          }, false);

          $video.addEventListener('error', reject);
        });

        if (time > 1) {
          $video.currentTime = time;
        } else if (time > 0) {
          $video.currentTime = $video.duration * time;
        }
        
        return promise;
      }
        
      function bitmapToCanvas(bitmap) {
        const canvas = document.createElement('canvas');
        canvas.height = bitmap.height;
        canvas.width = bitmap.width;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height);
        
        return canvas;
      }
        
      function bitmapToDataURI(bitmap) {
        const mimeType = options.thumbnails.mimeType.type;
        const quality = options.thumbnails.mimeType.quality;

        const canvas = bitmapToCanvas(bitmap);
        return canvas.toDataURL(mimeType, quality);
      }

      async function setThumbnail(node, url) {
        const time = options.thumbnails.timestamp;
        const color = options.thumbnails.color;
        const opacity = options.thumbnails.opacity;

        const thumbnail = await getThumbnailDataURI(url, time);

        if (thumbnail && thumbnail.length > 30) {
          node.style.setProperty('--image-url',`url(${thumbnail})`);
          node.style.setProperty('--rgba-color', `${color}, ${opacity}`);
        }

        return thumbnail;
      }
        
      async function getThumbnailDataURI(url, time) {
        const size = options.thumbnails.size;
        
        const key = `${size}|${time}|${url};`;
        try {
          const cached = retrieve(key);

          if (cached) {
            return cached;
          } else {
            const $video = await getVideo(url);

            time = (time >= 1 ? time : $video.duration * time);

            const bitmap = await getBitmap($video, time);

            $video.src = ''; // Unset video

            const dataURI = bitmapToDataURI(bitmap);
            store(key, dataURI);

            return dataURI;
          }
        } catch (e) { }
      }

      function store(key, val) {
        try {
          return localStorage.setItem(key, val);
        } catch (e) {
          return null;
        }
      }

      function retrieve(key) {
        try {
          return localStorage.getItem(key);
        } catch (e) {
          return null;
        }
      }


      // main()
      async function main() {       
        $('.replay').on('click', actionReplay);
        $('.skip').on('click', actionSkip);
        $('.stop').on('click', actionStop);
        $video.on('error', (e) => $video.poster = options.poster);

        setVideoPoster(0,0,0);

        const hash = getHash();
        
        if (hash && hash.location && hash.location.length > 1) {
          createLinks(hash.location);
        } else {
          createLinks();
        }

        $(window).on('popstate', (e) => {
          const hash = getHash();
          if (hash && hash.location && hash.location.length > 1) createLinks(hash.location)
        });

        if (hash && hash.video && hash.video.length > 1) {
          $video.muted = true; /* Autoplay on load only works if it is muted */
          actionPlay(hash.video);
        }
      }

      main();


      // jQuery-like syntactic sugar
      function $(query) {
        const el = (typeof query === 'string' ? document.querySelector.apply(document, arguments) : query);

        if (el) {
          el.on = function $on(e, fn, ...args) {
            if (args.length > 0) {
              return el.addEventListener(e, fn, ...args);
            } else {
              return el.addEventListener(e, fn, false);
            }
          }

          el.trigger = (eventType, detail) => {
            detail = (detail ? { detail: detail } : undefined);
            const e = new CustomEvent(eventType, detail);
            el.dispatchEvent(e);
          };

          el.hasClass = (c) => el.classList.contains(c);
        }

        return el;
      }
    })(this);
  </script>
</body>

</html>